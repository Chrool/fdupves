#!/usr/bin/perl

use warnings;
use strict;

use Config::Tiny;
use utf8;
use Data::Dumper;
use Getopt::Long;
use File::Basename;
use File::Copy;
use File::Find;
use File::Spec::Functions;
use Perl::OSType qw/is_os_type/;
use File::Path qw/make_path/;
use Digest::SHA qw/sha1_hex/;

use User;
use Wx qw(:everything);
use Wx::Event qw/EVT_TOOL/;

# GLobal configurations
my $config;

# Process data
my @dir;
my %cache;
my @same_files;
my $gui;

my %imghash;

# Script Starts here
my $OsIsWin = 0;
if (is_os_type ('Windows')) {
  $OsIsWin = 1;
}

&load_default_conf;

my $UserHome = User->Home;
my $ConfFile = catfile ($UserHome, '.fdupvesrc');

# First, parse the configuration file
&load_file_conf or die "Load configuration file error\n";

# Second, parse the command line option
&load_cmd_conf or die "Load command line options error\n";

# Set src file list from command line
for (@ARGV) {
  $_ =~ s/^\~/$UserHome/;
  $_ = File::Spec->rel2abs ($_) unless (file_name_is_absolute ($_));
  push @dir, $_;
}

if ($config->{workpath} =~ /^\~/) {
  my @dirs = File::Spec->splitdir ($config->{workpath});
  shift @dirs;
  $config->{workpath} = catdir ($UserHome, @dirs);
}

my $imghash_file = catfile ($config->{workpath}, "imghash.dat");
# load img hash
if (open FH, '<', $imghash_file) {
  while (<FH>) {
    chomp;
    my ($key, $value) = split /\|\|\|\|/, $_;
    $imghash{$key} = $value;
  }
  close FH;
}

&gui_init;

# Save the cache data before exit
END {
  # Save conf
  if ($ConfFile && $config->{video_timers}) {
    &save_file_conf;
  }

  # Save img hash and exit
  if ($imghash_file) {
    open FH, '>', $imghash_file;
    for (keys %imghash) {
      my $str = join ('||||', $_, $imghash{$_}) . "\n";
      print FH $str;
    }
    close FH;
  }
}

sub load_default_conf {
  $config = {
	     delete => 0,
	     symlinks => 0,
	     workpath => "~/.fdupves.d/cache",
	     method => "auto",
	     no_gui => 0,
	     yes => 0,
	     verbose => 0,
	     player => 'mplayer',

	     img_suffix => [
			    '.jpeg',
			    '.jpg',
			    '.bmp',
			    '.png',
			   ],

	     av_suffix => [
			   ".avi",
			   ".rmvb",
			   ".rm",
			   ".mp4",
			   ".mkv",
			   ".3gp",
			   ".flv",
			   ".vob",
			   ".wmv",
			   ".mov",
			   ".swf",
			  ],

	     compare_count => 4,

	     hash_size => [
			   8,
			   8,
			  ],
	     thumb_size => [
			    512,
			    384
			   ],

	     video_timers => [
			      [ 5, 15, 1 ],
			      [ 10, 90, 3 ],
			      [ 60, 600, 10 ],
			      [ 480, 2400, 60 ],
			      [ 1800, 28800, 120 ],
			     ],
	    };
}

sub load_file_conf {
  my $ini = Config::Tiny->read ($ConfFile);

  for my $k (keys %{$ini->{_}}) {

    if ($k eq 'av_suffix'
	|| $k eq 'img_suffix'
	|| $k eq 'hash_size'
	|| $k eq 'thumb_size'
       ) {
      my @items = split / /, $ini->{_}->{$k};
      $config->{$k} = \@items;

    } elsif ($k eq 'video_timers') {
      my @timers = split / /, $ini->{_}->{video_timers};

      delete $config->{video_timers};

      for (@timers) {
	my @secs = split /,/, $_;
	push @{$config->{video_timers}}, \@secs;
      }

    } else {
      $config->{$k} = $ini->{_}->{$k};
    }
  }
  1;
}

sub save_file_conf {
  my $ini = Config::Tiny->new;

  for my $k (keys %{$config}) {
    if ($k eq 'av_suffix'
	|| $k eq 'img_suffix'
	|| $k eq 'hash_size'
	|| $k eq 'thumb_size'
       ) {
      $ini->{_}->{$k} = join ' ', @{$config->{$k}};

    } elsif ($k eq 'video_timers') {
      my @timers;
      for my $i (@{$config->{$k}}) {
	push @timers, join ',', @{$i};
      }
      $ini->{_}->{video_timers} = join ' ', @timers;

    } else {
      $ini->{_}->{$k} = $config->{$k};
    }
  }

  $ini->write ($ConfFile);
}

sub load_cmd_conf {
  GetOptions (
	      "delete"   => \$config->{delete},
	      "symlinks" => \$config->{symlinks},
	      "C|workpath=s" => \$config->{workpath},
	      "no_gui" => \$config->{no_gui},
	      "yes" => \$config->{yes},
	      "method=s" => \$config->{method},
	      "verbose"  => \$config->{verbose},
	      "player=s" => \$config->{player},
	      "help" => sub { &display_help; exit; },
	     );
}

sub process_dir {
  if ($config->{method} ne 'length'
      && $config->{method} ne 'auto'
      && $config->{method} ne 'manual') {
    die "Method option is not set correctly";
  }

  find (\&find_filter, @dir);

  die "no enough av files to process" if (keys %cache < 2);

  if ($config->{method} eq 'length') {
    &process_by_length;
  } elsif ($config->{method} eq 'auto') {
    &process_auto;
  } elsif ($config->{method} eq 'manual') {
    &process_manual;
  }
}

sub display_sames {
  my $self = shift;

  # Clear the result tree first
  $self->{res_tree}->DeleteAllItems;

  my $root = $self->{res_tree}->AddRoot ('');

  for my $samefilesp (@same_files) {
    my $parent = $self->{res_tree}->AppendItem ($root, $samefilesp->[0],
						-1);
    for my $id (1 .. @{$samefilesp} - 1) {
      $self->{res_tree}->AppendItem ($parent,
				     $samefilesp->[$id],
				     -1);
    }
    if ($config->{delete}) {
      do {
	printf "\nWhich one does you hope keep?[1->%d] or 'all'\n", @$samefilesp;
	my $answer = <STDIN>;
	chomp $answer;

	next if ($answer =~ /a(ll)*/ && ($answer > @$samefilesp || $answer < 1));

	if ($answer > 0 && $answer <= @$samefilesp) {
	  for my $id (1 .. @{$samefilesp}) {
	    unlink $samefilesp->[$id] unless ($id == $answer);
	  }
	}
      } while (1);
    }
  }

  $self->{res_tree}->ExpandAll;
}

sub gui_init {
  my $app = Wx::SimpleApp->new;
  my $frame = Wx::Frame->new (undef,
			      -1,
			      "fdupves - find duplicate video files",
			      [-1, -1],
			      [600, 720]
			     );

  $gui = $frame;		#global variable

  Wx::InitAllImageHandlers;	#init img handlers

  ui_toolbar_new ($frame);
  ui_childarea_new ($frame);
  ui_statusbar_new ($frame);

  $frame->Show;
  $app->MainLoop;
}

sub ui_toolbar_new {
  my $self = shift;
  my $toolbar = $self->CreateToolBar (wxTB_TEXT|wxTB_NOICONS);
  $toolbar->SetMargins (5, 5);
  $toolbar->SetSize ([-1, 50]);

  my @toolbars = (
		  ['Add', \&but_add_clicked, 'add directories for find'],
		  ['Find', \&but_find_clicked, 'find duplicate video files'],
		  ['Preference', \&but_pref_clicked, 'set preference'],
		 );

  for (0 .. @toolbars - 1) {
    $toolbar->AddTool (100 + $_, $toolbars[$_]->[0], wxNullBitmap,
		       $toolbars[$_]->[2]);
    EVT_TOOL ($self, 100 + $_, $toolbars[$_]->[1]);
  }

  $toolbar->Realize;
}

sub ui_childarea_new {
  my $self = shift;

  $self->{vsizer} = Wx::BoxSizer->new (wxVERTICAL);
  $self->{dir_win} = Wx::ScrolledWindow->new ($self,
					      -1,
					      [ -1, -1 ],
					      [ 295, 700 ],
					     );
  $self->{vsizer}->Add ($self->{dir_win});

  my $sizer = Wx::BoxSizer->new (wxVERTICAL);
  $self->{dir_win}->SetSizerAndFit ($sizer);

  $self->{dir_list} = Wx::ListCtrl->new ($self,
					 -1,
					 [ -1, -1 ],
					 [ 295, 600 ],
					);
  $sizer->Add ($self->{dir_list});

  # load the command line input directoies
  for (@dir) {
    my $item = Wx::ListItem->new;
    $item->SetText ($_);
    $self->{dir_list}->InsertItem ($item);
  }

  $self->{res_win} = Wx::ScrolledWindow->new ($self,
					      -1,
					      [ 300, -1 ],
					      [ 300, 700 ],
					     );
  $self->{vsizer}->Add ($self->{res_win});

  $sizer = Wx::BoxSizer->new (wxVERTICAL);
  $self->{res_win}->SetSizerAndFit ($sizer);

  $self->{res_tree} = Wx::TreeCtrl->new ($self,
					 -1,
					 [ 300, -1 ],
					 [ 300, 600 ],
					);
  $sizer->Add ($self->{res_tree});
}

sub ui_statusbar_new {
  my $self = shift;
  $self->{statusbar} = $self->CreateStatusBar;
}

sub but_add_clicked {
  my $self = shift;

  my $dia = Wx::DirDialog->new ($self,
				"Choose a directory",
				"",
				wxDD_DIR_MUST_EXIST);
  my $res = $dia->ShowModal;
  if ($res == wxID_OK) {
    push @dir, $dia->GetPath;

    my $item = Wx::ListItem->new;
    $item->SetText ($dia->GetPath);
    $self->{dir_list}->InsertItem ($item);
  }
}

sub but_find_clicked {
  my $self = shift;

  unless (@dir) {
    my $mes = Wx::MessageDialog->new ($self,
				      "Please 'Add' source directory first.",
				      "Warn",
				      wxOK | wxICON_HAND | wxSTAY_ON_TOP
				     );
    $mes->ShowModal;
    return;
  }

  &process_dir;

  display_sames ($self);
}

sub but_pref_clicked {
  my $self = shift;
}

sub process_by_length {
  my @sort_list = sort {
    $cache{$a}->{info}->{id_length}
      <=> $cache{$b}->{info}->{id_length}
    } keys %cache;

  my $curid = 0;
  for my $id (0 .. @sort_list - 2) {
    next if ($id < $curid);

    my $file = $sort_list[$id];
    my @samefiles = ($file);

    for my $nextid ($id + 1 .. @sort_list - 1) {
      $curid = $nextid;

      my $nextfile = $sort_list[$nextid];
      if ($cache{$file}->{info}->{id_length} == $cache{$nextfile}->{info}->{id_length}) {
	push @samefiles, $nextfile;
      } else {
	last;
      }
    }

    if (@samefiles > 1) {
      push @same_files, \@samefiles;
    }
  }
}

sub process_auto {
  my $sort_group_files = &sort_img_by_similar;

  for my $sort_files (@$sort_group_files) {
    for my $file (@{$sort_files}) {
      # break when hash distance >5
      last if ($cache{$file}->{min_hash} > 5);

      my $nextfile = $cache{$file}->{min_file};

      my $shorter = $cache{$file}->{info}->{id_length};
      $shorter = $cache{$nextfile}->{info}->{id_length} if ($cache{$nextfile}->{info}->{id_length}
							    < $shorter);
      my $interval = $shorter / ($config->{compare_count});

      my $equ = 1;
      for (1 .. $config->{compare_count} - 1) {
	my $ss = $cache{$file}->{min_chunk} + $_ * $interval;
	$ss =
	  $cache{$file}->{info}->{id_length}
	    - $cache{$file}->{min_chunk}
	      - $_ * $interval if ($cache{$file}->{min_type} == 1);

	my $hasha = get_imghash ($file, $ss);
	my $hashb = get_imghash ($nextfile, $ss);
	if (imghash_cmp ($hasha, $hashb) > 5) {
	  $equ = 0;
	  last;
	}
      }

      # find the previous duplicate files
      my $has_find = 0;
      for my $sfs (@same_files) {
	for my $curfile (@{$sfs}) {
	  if ($curfile eq $file) {
	    push @{$sfs}, $nextfile unless (grep { $nextfile eq $_ } @{$sfs});
	    $has_find = 1;
	  }
	}
      }

      unless ($has_find) {
	my @sfs = ($file, $nextfile);
	push @same_files, \@sfs;
      }
    }
  }
}

sub process_manual {
  my $sort_group_files = &sort_img_by_similar;

  for my $sort_files (@$sort_group_files) {
    for my $file (@{$sort_files}) {
      # break when hash distance >5
      last if ($cache{$file}->{min_hash} > 5);

      my $nextfile = $cache{$file}->{min_file};

      my $shorter = $cache{$file}->{info}->{id_length};
      $shorter = $cache{$nextfile}->{info}->{id_length} if ($cache{$nextfile}->{info}->{id_length}
							    < $shorter);
      my $interval = $shorter / ($config->{compare_count});

      my @inputs;
      for (0 .. $config->{compare_count} - 1) {
	my $ss = $cache{$file}->{min_chunk} + $_ * $interval;
	$ss =
	  $cache{$file}->{info}->{id_length}
	    - $cache{$file}->{min_chunk}
	      - $_ * $interval if ($cache{$file}->{min_type} == 1);
	my $pica = catfile ($cache{$file}->{cache_dir},
			    $ss . ".jpg");
	get_screenshot ($file, $ss, $pica) unless (-r $pica);
	push @inputs, $pica;

	my $picb = catfile ($cache{$nextfile}->{cache_dir},
			    $ss . ".jpg");
	get_screenshot ($nextfile, $ss, $picb) unless (-r $picb);
	push @inputs, $picb;
      }

      my $yes = user_confirm ($gui, $file, $nextfile, \@inputs);

      next unless ($yes);

      # find the previous duplicate files
      my $has_find = 0;
      for my $sfs (@same_files) {
	for my $curfile (@{$sfs}) {
	  if ($curfile eq $file) {
	    push @{$sfs}, $nextfile;
	    $has_find = 1;
	  }
	}
      }

      unless ($has_find) {
	my @sfs = ($file, $nextfile);
	push @same_files, \@sfs;
      }
    }
  }
}

sub user_confirm {
  my ($self, $file, $nextfile, $inputs) = @_;

  my $dia = Wx::Dialog->new (undef,
			     -1,
			     "Yes or No",
			    );
  my $sizer = $dia->CreateButtonSizer (wxYES | wxNO);
  my $lines = (@$inputs + 1) / 2;
  my $gsizer = Wx::GridSizer->new ($lines, 2);
  $sizer->Add ($gsizer, wxEXPAND);

  for my $id (0 .. $lines - 1) {
    my $imgfile = $inputs->[$id * 2];
    my $img = Wx::Bitmap->new ($imgfile,
			       wxBITMAP_TYPE_JPEG
			      );
    my $bitmap = Wx::StaticBitmap->new ($self,
					wxID_ANY,
					$img
				       );
    $gsizer->Add ($bitmap);

    my $nextimgfile = $inputs->[$id * 2 + 1];
    my $nextimg = Wx::Bitmap->new ($nextimgfile,
				   wxBITMAP_TYPE_JPEG
				  );
    my $nextbitmap = Wx::StaticBitmap->new ($self,
					    wxID_ANY,
					    $nextimg
					   );
    $gsizer->Add ($nextbitmap);
  }

  my $yes = $dia->ShowModal;
  $dia->Destroy;
  if ($yes == wxID_YES) {
    return 1;
  } else {
    return 0;
  }
}

sub ask_if_same {
  my ($file, $nextfile) = @_;

  return $config->{yes} if ($config->{yes});

  my $localyes;
  printf "Is \n\t$file\n\t$nextfile\n are same?\n[y[es]/n[o]/a[ll]";
  my $answer = <STDIN>;
  chomp $answer;
  if ($answer =~ /^[yY].*/) {
    $localyes = 1;
  } elsif ($answer =~ /^[aA].*/) {
    $config->{yes} = 1;
    $localyes = 1;
  } else {
    $localyes = 0;
  }

  $localyes;
}

sub sort_img_by_similar {
  my %compared_files;
  my @group_files;
  my @sort_group_files;

  for my $timer_id (0 .. @{$config->{video_timers}} - 1) {
    my @grep_files = grep { $cache{$_}->{info}->{id_length} >= $config->{video_timers}->[$timer_id]->[0]
			      && $cache{$_}->{info}->{id_length} < $config->{video_timers}->[$timer_id]->[1] } keys %cache;
    push @group_files, \@grep_files;
  }

  for my $groupid (0 .. @group_files - 1) {
    my @files = @{$group_files[$groupid]};
    my $chunk = $config->{video_timers}->[$groupid]->[2];

    next unless (@files);

    my $hassame = 0;
    for my $id (0 .. @files - 2) {
      my $file = $files[$id];
      my $beginhash = get_imghash ($file, $chunk);
      my $endhash = get_imghash ($file, $cache{$file}->{info}->{id_length} - $chunk);

      my $min = $config->{hash_size}->[0] * $config->{hash_size}->[1];
      $min = $cache{$file}->{min_hash} if ($cache{$file}->{min_file});

      for my $nextid ($id + 1 .. @files - 1) {
	my $nextfile = $files[$nextid];

	my $compkey = sprintf ("%s:%s", $cache{$file}->{phrase}, $cache{$nextfile}->{phrase});
	next if (exists $compared_files{$compkey});
	$compared_files{$compkey} = 1;

	my $nextbeginhash = get_imghash ($nextfile, $chunk);
	my $nextendhash = get_imghash ($nextfile, $cache{$nextfile}->{info}->{id_length} - $chunk);

	my $begin = imghash_cmp ($beginhash, $nextbeginhash);
	if ($begin < $min) {
	  $cache{$file}->{min_file} = $nextfile;
	  $cache{$file}->{min_hash} = $begin;
	  $cache{$file}->{min_type} = 0;
	  $cache{$file}->{min_chunk} = $chunk;
	  $min = $begin;
	  $hassame = 1;
	}
	my $end = imghash_cmp ($endhash, $nextendhash);
	if ($end < $min) {
	  $cache{$file}->{min_file} = $nextfile;
	  $cache{$file}->{min_hash} = $end;
	  $cache{$file}->{min_type} = 1;
	  $cache{$file}->{min_chunk} = $chunk;
	  $min = $end;
	  $hassame = 1;
	}
      }
    }

    next unless ($hassame);

    my @has_files = grep { defined $cache{$_}->{min_hash} } @files;
    my @sort_list = sort {
      $cache{$a}->{min_hash} <=> $cache{$b}->{min_hash}
    } @has_files;

    push @sort_group_files, \@sort_list;
  }

  return \@sort_group_files;
}

sub get_screenshot {
  if ("\L$config->{player}\E" =~ /mplayer/) {
    get_screenshot_by_mplayer (@_);
  }
}

sub get_screenshot_by_mplayer {
  my ($file, $time, $img) = @_;

  my ($name, $dir) = fileparse ($img);
  make_path ($dir);

  my $cmd =  "$config->{player} -ss $time -noframedrop -nosound -vo jpeg -frames 1 \"$file\"";
  unless ($OsIsWin || $config->{verbose}) {
    $cmd .= " >/dev/null 2>&1";
  }

  eval {
    local $SIG{ALRM} = sub { die "timeout\n" };
    alarm 5;
    `$cmd`;
    alarm 0;
  };
  if ($@) {
    printf "ERROR: get file \'$file\' screenshot failed\n";
  }

  move "00000001.jpg", $img;
}

sub img_resize {
  my ($src, $out, @thumb) = @_;

  my $img = Wx::Image->new ($src, wxBITMAP_TYPE_JPEG);
  $img->Rescale (@thumb);
  $img->SaveFile ($out, wxBITMAP_TYPE_JPEG);
}

sub img_combine {
  my ($out, @files) = @_;

  #  my $img = Image::Magick->new;
  #  $img->Read ($_) for (@files);
  #  my $montage = $img->Montage (tile => 2,
  #			       geometry => '+0+0');
  #  $montage->Write ($out);
}

sub get_imghash_key {
  join '::::', @_;
}

sub get_imghash {
  my ($file, $timer) = @_;

  my $hashkey = get_imghash_key ($file, $timer);
  if (exists $imghash{$hashkey}) {
    return $imghash{$hashkey};
  }

  my $imgfile = catfile ($cache{$file}->{cache_dir}, $timer . '.jpg');
  get_screenshot ($file, $timer, $imgfile) unless (-r $imgfile);

  return unless (-r $imgfile);

  my $img = Wx::Image->new ($imgfile, wxBITMAP_TYPE_JPEG);
  $img->Rescale (@{$config->{hash_size}});

  my @phrase;
  for my $w (0 .. $img->GetWidth - 1) {
    for my $h (0 .. $img->GetHeight - 1) {
      my($r, $g, $b) = ($img->GetRed ($w, $h),
			$img->GetGreen ($w, $h),
			$img->GetBlue ($w, $h)
		       );
      my $ch = ($r * 30 + $g * 59 + $b * 11) / 100;
      push @phrase, $ch;
    }
  }

  my $sum = 0;
  for (@phrase) {
    $sum += $_;
  }
  my $avg = $sum / @phrase;

  my $bin = 0;
  for (0 .. @phrase - 1) {
    $bin |= (1 << $_) if ($phrase[$_] >= $avg);
  }

  $imghash{$hashkey} = "$bin";
}

sub imghash_cmp {
  my ($bina, $binb) = @_;

  return $config->{hash_size}->[0] * $config->{hash_size}->[1] unless ($bina && $binb);

  my $sum = 0;
  my $odd = int ((int $bina) ^ (int $binb));
  while ($odd) {
    $sum ++ if ($odd & 1);
    $odd = $odd >> 1;
  }
  $sum;
}

sub find_filter {
  my $file = $File::Find::name;

  return if (-d $file);

  return unless (is_avfile ($file));

  file_parse ($file);
}

sub file_parse {
  my $file = shift;

  my $info = get_info ($file);
  return unless ($info);

  my %nodes;
  $nodes{info} = $info;
  $cache{$file} = \%nodes;

  my $phrase = substr sha1_hex ($file), 0, 16;

  $nodes{phrase} = $phrase;
  $nodes{cache_dir} = catdir ($config->{workpath}, substr ($phrase, 0, 2), $phrase);
}

sub is_avfile {
  my $file = shift;
  my (undef, undef, $suffix) = fileparse ($file, @{$config->{av_suffix}});
  return 1 if ("\L$suffix\E" ~~ @{$config->{av_suffix}});
  0;
}

sub get_info {
  if ("\L$config->{player}\E" =~ /mplayer/) {
    return get_info_by_mplayer (@_);
  }
}

sub get_info_by_mplayer {
  my $file = shift;
  my @mpout;

  my $cmd = "$config->{player} -identify -nosound -vc dummy -vo null \"$file\"";
  unless ($OsIsWin || $config->{verbose}) {
    $cmd .= " 2>/dev/null";
  }

  eval {
    local $SIG{ALRM} = sub { die "timeout\n" };
    alarm 5;
    @mpout = `$cmd`;
    alarm 0;
  };
  if ($@) {
    printf "ERROR: \'$file\' get id_length error.\n";
    return;
  }

  my %info;

  my ($len_line) = grep (/ID_LENGTH/, @mpout);
  if ($len_line && $len_line =~ /ID_LENGTH=(\d*\.\d*)/) {
    $info{id_length} = $1;
  } else {
    $info{id_length} = 0;
  }

  return \%info;
}

sub display_help {
  my $str = "
    fdupves is a Perl script for finding duplicate video files in a given set of directories.
      -r -recuse
	include files residing in subdirectories

      -s -symlinks
        follow symlinked directories

      -y -yes
        not ask user, just think as yes

      -C -workpath
	output screenshot pics will be store here

      -m method
        compare method (length, auto, or manual)
          lenght: lowest level compare, just compare the video length
          auto: compare some screenshots in video automatically
          manual: compare some screenshots and display to user

      -d --delete
	prompt  user  for  files  to  preserve, deleting all others

      -v --verbose
	display more debug infomations

      -h --help
	displays help
";

  print $str;
}
