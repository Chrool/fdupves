#!/usr/bin/perl

use v5.14;
use warnings;
use strict;

use Config::Tiny;
use utf8;
use Data::Dumper;
use Getopt::Long;
use File::Basename;
use File::Copy;
use File::Find;
use File::Spec::Functions;
use Perl::OSType qw/is_os_type/;
use File::Path qw/make_path/;
use Digest::SHA qw/sha1_hex/;

use User;
use Wx qw(:everything);
use Wx::Event qw/EVT_TOOL/;

# GLobal configurations
my $config;

# Process data
my @dir;
my %cache;
my @same_files;

# Script Starts here
my $OsIsWin = 0;
if (is_os_type ('Windows')) {
  $OsIsWin = 1;
}

&load_default_conf;

my $UserHome = User->Home;
my $ConfFile = catfile ($UserHome, '.fdupvesrc');
my $CacheFile = catfile ($UserHome, '.fdupves.cache');

# First, parse the configuration file
&load_file_conf or die "Load configuration file error\n";

# Second, parse the command line option
&load_cmd_conf or die "Load command line options error\n";

# Set src file list from command line
for (@ARGV) {
  $_ =~ s/^\~/$UserHome/;
  $_ = File::Spec->rel2abs ($_) unless (file_name_is_absolute ($_));
  push @dir, $_;
}

if ($config->{workpath} =~ /^\~/) {
  my @dirs = File::Spec->splitdir ($config->{workpath});
  shift @dirs;
  $config->{workpath} = catdir ($UserHome, @dirs);
}

# load img hash
if (open FH, '<', $CacheFile) {
  while (<FH>) {
    chomp;
    my ($file, $timer, $value) = split /\|\|\|\|/, $_;
    $cache{$file}->{hash}->{$timer} = $value;
  }
  close FH;
}

&gui_init;

# Save the cache data before exit
END {
  # Save conf
  if ($ConfFile) {
    &save_file_conf;
  }

  # Save img hash and exit
  if ($CacheFile) {
    open FH, '>', $CacheFile;
    for my $file (keys %cache) {
      while (my ($timer, $hash) = each %{$cache{$file}->{hash}}) {
	my $str = join ('||||', $file, $timer, $hash) . "\n";
	print FH $str;
      }
    }
    close FH;
  }
}

sub load_default_conf {
  $config = {
	     delete => 0,
	     symlinks => 0,
	     workpath => "~/.fdupves.d/cache",
	     method => "auto",
	     yes => 0,
	     verbose => 0,
	     player => 'mplayer',

	     img_suffix => [
			    '.jpeg',
			    '.jpg',
			    '.bmp',
			    '.png',
			   ],

	     av_suffix => [
			   ".avi",
			   ".rmvb",
			   ".rm",
			   ".mp4",
			   ".mkv",
			   ".3gp",
			   ".flv",
			   ".vob",
			   ".wmv",
			   ".mov",
			   ".swf",
			  ],

	     compare_count => 4,

	     hash_size => [
			   8,
			   8,
			  ],
	     thumb_size => [
			    512,
			    384
			   ],

	     video_timers => [
			      [ 5, 15, 1 ],
			      [ 10, 90, 3 ],
			      [ 60, 600, 10 ],
			      [ 480, 2400, 60 ],
			      [ 1800, 28800, 120 ],
			     ],
	    };
}

sub load_file_conf {
  my $ini = Config::Tiny->read ($ConfFile);

  for my $k (keys %{$ini->{_}}) {

    if ($k eq 'av_suffix'
	|| $k eq 'img_suffix'
	|| $k eq 'hash_size'
	|| $k eq 'thumb_size'
       ) {
      my @items = split / /, $ini->{_}->{$k};
      $config->{$k} = \@items;

    } elsif ($k eq 'video_timers') {
      my @timers = split / /, $ini->{_}->{video_timers};

      delete $config->{video_timers};

      for (@timers) {
	my @secs = split /,/, $_;
	push @{$config->{video_timers}}, \@secs;
      }

    } else {
      $config->{$k} = $ini->{_}->{$k};
    }
  }
  1;
}

sub save_file_conf {
  my $ini = Config::Tiny->new;

  for my $k (keys %{$config}) {
    if ($k eq 'av_suffix'
	|| $k eq 'img_suffix'
	|| $k eq 'hash_size'
	|| $k eq 'thumb_size'
       ) {
      $ini->{_}->{$k} = join ' ', @{$config->{$k}};

    } elsif ($k eq 'video_timers') {
      my @timers;
      for my $i (@{$config->{$k}}) {
	push @timers, join ',', @{$i};
      }
      $ini->{_}->{video_timers} = join ' ', @timers;

    } else {
      $ini->{_}->{$k} = $config->{$k};
    }
  }

  $ini->write ($ConfFile);
}

sub load_cmd_conf {
  GetOptions (
	      "delete"   => \$config->{delete},
	      "symlinks" => \$config->{symlinks},
	      "C|workpath=s" => \$config->{workpath},
	      "yes" => \$config->{yes},
	      "method=s" => \$config->{method},
	      "verbose"  => \$config->{verbose},
	      "player=s" => \$config->{player},
	      "help" => sub { &display_help; exit; },
	     );
}

sub process_dir {
  my $self = shift;
  if ($config->{method} ne 'length'
      && $config->{method} ne 'auto'
      && $config->{method} ne 'manual') {
    die "Method option is not set correctly";
  }

  find ({wanted => \&find_filter,
	 follow => $config->{symlinks},
	 follow_skip => 2,
	}, @dir);

  die "no enough av files to process" if (keys %cache < 2);

  if ($config->{method} eq 'length') {
    process_by_length ($self);
  } elsif ($config->{method} eq 'auto') {
    process_auto ($self);
  } elsif ($config->{method} eq 'manual') {
    process_manual ($self);
  }
}

sub display_sames {
  my $self = shift;

  # Clear the result tree first
  $self->{res_tree}->DeleteAllItems;

  my $root = $self->{res_tree}->AddRoot ('');

  for my $samefilesp (@same_files) {
    my $parent = $self->{res_tree}->AppendItem ($root, $samefilesp->[0],
						-1);
    for my $id (1 .. @{$samefilesp} - 1) {
      $self->{res_tree}->AppendItem ($parent,
				     $samefilesp->[$id],
				     -1);
    }
    if ($config->{delete}) {
      do {
	printf "\nWhich one does you hope keep?[1->%d] or 'all'\n", @$samefilesp;
	my $answer = <STDIN>;
	chomp $answer;

	next if ($answer =~ /a(ll)*/ && ($answer > @$samefilesp || $answer < 1));

	if ($answer > 0 && $answer <= @$samefilesp) {
	  for my $id (1 .. @{$samefilesp}) {
	    unlink $samefilesp->[$id] unless ($id == $answer);
	  }
	}
      } while (1);
    }
  }

  $self->{res_tree}->ExpandAll;
}

sub gui_init {
  my $app = Wx::SimpleApp->new;
  my $frame = Wx::Frame->new (undef,
			      -1,
			      "fdupves - find duplicate video files",
			      [-1, -1],
			      [1024, 728]
			     );

  Wx::InitAllImageHandlers;	#init img handlers

  ui_toolbar_new ($frame);
  ui_childarea_new ($frame);
  ui_statusbar_new ($frame);

  $frame->Show;
  $app->MainLoop;
}

sub ui_toolbar_new {
  my $self = shift;
  my $toolbar = $self->CreateToolBar (wxTB_TEXT|wxTB_NOICONS);
  $toolbar->SetMargins (5, 5);
  $toolbar->SetSize ([-1, 50]);

  my @toolbars = (
		  ['Add', \&but_add_clicked, 'add directories for find'],
		  ['Find', \&but_find_clicked, 'find duplicate video files'],
		  ['Preference', \&but_pref_clicked, 'set preference'],
		 );

  for (0 .. @toolbars - 1) {
    $toolbar->AddTool (100 + $_, $toolbars[$_]->[0], wxNullBitmap,
		       $toolbars[$_]->[2]);
    EVT_TOOL ($self, 100 + $_, $toolbars[$_]->[1]);
  }

  $toolbar->Realize;
}

sub ui_childarea_new {
  my $self = shift;

  $self->{vsizer} = Wx::BoxSizer->new (wxHORIZONTAL);

  $self->{dir_win} = Wx::ScrolledWindow->new ($self,
					      -1,
					     );
  $self->{vsizer}->Add ($self->{dir_win}, 1, wxEXPAND|wxALL, 0);

  my $sizer = Wx::BoxSizer->new (wxVERTICAL);
  $self->{dir_list} = Wx::ListCtrl->new ($self->{dir_win},
					 -1,
					);
  $sizer->Add ($self->{dir_list}, 1, wxEXPAND|wxALL, 5);

  $self->{dir_win}->SetSizer ($sizer);

  # load the command line input directoies
  for (@dir) {
    my $item = Wx::ListItem->new;
    $item->SetText ($_);
    $self->{dir_list}->InsertItem ($item);
  }

  $self->{res_win} = Wx::ScrolledWindow->new ($self,
					      -1,
					     );
  $self->{vsizer}->Add ($self->{res_win}, 1, wxEXPAND, 0);

  $sizer = Wx::BoxSizer->new (wxVERTICAL);
  $self->{res_tree} = Wx::TreeCtrl->new ($self->{res_win},
					 -1,
					);
  $sizer->Add ($self->{res_tree}, 1, wxEXPAND|wxALL, 5);

  $self->{res_win}->SetSizer ($sizer);

  $self->SetSizer ($self->{vsizer});
  $self->{vsizer}->SetSizeHints ($self);
}

sub ui_statusbar_new {
  my $self = shift;
  $self->{statusbar} = $self->CreateStatusBar;
}

sub but_add_clicked {
  my $self = shift;

  my $dia = Wx::DirDialog->new ($self,
				"Choose a directory",
				"",
				wxDD_DIR_MUST_EXIST);
  my $res = $dia->ShowModal;
  if ($res == wxID_OK) {
    push @dir, $dia->GetPath;

    my $item = Wx::ListItem->new;
    $item->SetText ($dia->GetPath);
    $self->{dir_list}->InsertItem ($item);
  }
}

sub but_find_clicked {
  my $self = shift;

  unless (@dir) {
    my $mes = Wx::MessageDialog->new ($self,
				      "Please 'Add' source directory first.",
				      "Warn",
				      wxOK | wxICON_HAND | wxSTAY_ON_TOP
				     );
    $mes->ShowModal;
    return;
  }

  process_dir ($self);

  display_sames ($self);
}

sub but_pref_clicked {
  my $self = shift;
}

sub process_by_length {
  my $self = shift;

  my @sort_list = sort {
    $cache{$a}->{info}->{length}
      <=> $cache{$b}->{info}->{length}
    } keys %cache;

  my $curid = 0;
  for my $id (0 .. @sort_list - 2) {
    next if ($id < $curid);

    my $file = $sort_list[$id];
    my @samefiles = ($file);

    for my $nextid ($id + 1 .. @sort_list - 1) {
      $curid = $nextid;

      my $nextfile = $sort_list[$nextid];
      if ($cache{$file}->{info}->{length} == $cache{$nextfile}->{info}->{length}) {
	push @samefiles, $nextfile;
      } else {
	last;
      }
    }

    if (@samefiles > 1) {
      push @same_files, \@samefiles;
    }
  }
}

sub process_auto {
  my $self = shift;
  my $sort_group_files = &sort_img_by_similar;

  for my $sort_files (@$sort_group_files) {
    for my $file (@{$sort_files}) {
      # break when hash distance >5
      last if ($cache{$file}->{min_hash} > 5);

      my $nextfile = $cache{$file}->{min_file};

      my $shorter = $cache{$file}->{info}->{length};
      $shorter = $cache{$nextfile}->{info}->{length} if ($cache{$nextfile}->{info}->{length}
							 < $shorter);
      my $interval = $shorter / ($config->{compare_count});

      my $equ = 1;
      for (1 .. $config->{compare_count} - 1) {
	my $ss = $cache{$file}->{min_chunk} + $_ * $interval;
	$ss =
	  $cache{$file}->{info}->{length}
	    - $cache{$file}->{min_chunk}
	      - $_ * $interval if ($cache{$file}->{min_type} == 1);

	my $hasha = get_imghash ($file, $ss);
	my $hashb = get_imghash ($nextfile, $ss);
	if (imghash_cmp ($hasha, $hashb) > 5) {
	  $equ = 0;
	  last;
	}
      }

      # find the previous duplicate files
      my $has_find = 0;
      for my $sfs (@same_files) {
	for my $curfile (@{$sfs}) {
	  if ($curfile eq $file) {
	    push @{$sfs}, $nextfile unless (grep { $nextfile eq $_ } @{$sfs});
	    $has_find = 1;
	  }
	}
      }

      unless ($has_find) {
	my @sfs = ($file, $nextfile);
	push @same_files, \@sfs;
      }
    }
  }
}

sub process_manual {
  my $self = shift;
  my $sort_group_files = &sort_img_by_similar;

  for my $sort_files (@$sort_group_files) {
    for my $file (@{$sort_files}) {
      # break when hash distance >5
      last if ($cache{$file}->{min_hash} > 5);

      my $nextfile = $cache{$file}->{min_file};

      my $shorter = $cache{$file}->{info}->{length};
      $shorter = $cache{$nextfile}->{info}->{length} if ($cache{$nextfile}->{info}->{length}
							 < $shorter);
      my $interval = $shorter / ($config->{compare_count});

      my @inputs;
      for (0 .. $config->{compare_count} - 1) {
	my $ss = $cache{$file}->{min_chunk} + $_ * $interval;
	$ss =
	  $cache{$file}->{info}->{length}
	    - $cache{$file}->{min_chunk}
	      - $_ * $interval if ($cache{$file}->{min_type} == 1);
	my $pica = catfile ($cache{$file}->{cache_dir},
			    $ss . ".jpg");
	get_screenshot ($file, $ss, $pica) unless (-r $pica);
	push @inputs, $pica;

	my $picb = catfile ($cache{$nextfile}->{cache_dir},
			    $ss . ".jpg");
	get_screenshot ($nextfile, $ss, $picb) unless (-r $picb);
	push @inputs, $picb;
      }

      my $yes = user_confirm ($self, $file, $nextfile, \@inputs);

      next unless ($yes);

      # find the previous duplicate files
      my $has_find = 0;
      for my $sfs (@same_files) {
	for my $curfile (@{$sfs}) {
	  if ($curfile eq $file) {
	    push @{$sfs}, $nextfile;
	    $has_find = 1;
	  }
	}
      }

      unless ($has_find) {
	my @sfs = ($file, $nextfile);
	push @same_files, \@sfs;
      }
    }
  }
}

sub user_confirm {
  my ($self, $file, $nextfile, $inputs) = @_;

  my $lines = int ((@$inputs + 1) / 2);
  my $w = $config->{thumb_size}->[0];
  my $h = $config->{thumb_size}->[1];

  my $dia = Wx::Dialog->new ($self,
			     wxID_ANY,
			     "Yes or No",
			    );
  my $sizer = Wx::BoxSizer->new (wxVERTICAL);

  my $gsizer = Wx::GridSizer->new ($lines, 2);
  $sizer->Add ($gsizer, 1, wxEXPAND, 10);

  for my $id (0 .. $lines - 1) {
    my $imgfile = $inputs->[$id * 2];
    my $imgpre = Wx::Image->new ($imgfile, wxBITMAP_TYPE_JPEG);
    $imgpre->Rescale ($w, $h);
    my $img = Wx::Bitmap->new ($imgpre);
    my $bitmap = Wx::StaticBitmap->new ($dia,
					wxID_ANY,
					$img,
				       );
    $gsizer->Add ($bitmap, 0);

    my $nextimgfile = $inputs->[$id * 2 + 1];
    my $nextimgpre = Wx::Image->new ($nextimgfile, wxBITMAP_TYPE_JPEG);
    $nextimgpre->Rescale ($w, $h);
    my $nextimg = Wx::Bitmap->new ($nextimgpre);
    my $nextbitmap = Wx::StaticBitmap->new ($dia,
					    wxID_ANY,
					    $nextimg,
					   );
    $gsizer->Add ($nextbitmap, 0);
  }

  my $tsizer = Wx::BoxSizer->new (wxHORIZONTAL);
  my $fileinfo = Wx::TextCtrl->new ($dia,
				    wxID_ANY,
				    file_info_string ($file),
				    [ -1, -1 ],
				    [ -1, -1 ],
				    wxTE_MULTILINE|wxTE_READONLY|wxTR_ROW_LINES,
				   );
  $tsizer->Add ($fileinfo, 1, wxEXPAND|wxALL, 0);
  my $nextfileinfo = Wx::TextCtrl->new ($dia,
					wxID_ANY,
					file_info_string ($nextfile),
					[ -1, -1 ],
					[ -1, -1 ],
					wxTE_MULTILINE|wxTE_READONLY|wxTR_ROW_LINES,
				       );
  $tsizer->Add ($nextfileinfo, 1, wxEXPAND|wxALL, 0);
  $sizer->Add ($tsizer, 0, wxEXPAND|wxALL, 4);

  my $bsizer = $dia->CreateButtonSizer (wxYES | wxCANCEL);
  $sizer->Add ($bsizer, 0, wxALIGN_CENTER_HORIZONTAL);

  $dia->SetSizer ($sizer);
  $sizer->SetSizeHints ($dia);

  my $yes = $dia->ShowModal;
  if ($yes == wxID_YES) {
    return 1;
  } else {
    return 0;
  }
}

sub sort_img_by_similar {
  my %compared_files;
  my @group_files;
  my @sort_group_files;

  for my $timer_id (0 .. @{$config->{video_timers}} - 1) {
    my @grep_files = grep { $cache{$_}->{info}->{length} >= $config->{video_timers}->[$timer_id]->[0]
			      && $cache{$_}->{info}->{length} < $config->{video_timers}->[$timer_id]->[1] } keys %cache;
    push @group_files, \@grep_files;
  }

  for my $groupid (0 .. @group_files - 1) {
    my @files = @{$group_files[$groupid]};
    my $chunk = $config->{video_timers}->[$groupid]->[2];

    next unless (@files);

    my $hassame = 0;
    for my $id (0 .. @files - 2) {
      my $file = $files[$id];
      my $beginhash = get_imghash ($file, $chunk);
      my $endhash = get_imghash ($file, $cache{$file}->{info}->{length} - $chunk);

      my $min = $config->{hash_size}->[0] * $config->{hash_size}->[1];
      $min = $cache{$file}->{min_hash} if ($cache{$file}->{min_file});

      for my $nextid ($id + 1 .. @files - 1) {
	my $nextfile = $files[$nextid];

	my $compkey = sprintf ("%s:%s", $cache{$file}->{phrase}, $cache{$nextfile}->{phrase});
	next if (exists $compared_files{$compkey});
	$compared_files{$compkey} = 1;

	my $nextbeginhash = get_imghash ($nextfile, $chunk);
	my $nextendhash = get_imghash ($nextfile, $cache{$nextfile}->{info}->{length} - $chunk);

	my $begin = imghash_cmp ($beginhash, $nextbeginhash);
	if ($begin < $min) {
	  $cache{$file}->{min_file} = $nextfile;
	  $cache{$file}->{min_hash} = $begin;
	  $cache{$file}->{min_type} = 0;
	  $cache{$file}->{min_chunk} = $chunk;
	  $min = $begin;
	  $hassame = 1;
	}
	my $end = imghash_cmp ($endhash, $nextendhash);
	if ($end < $min) {
	  $cache{$file}->{min_file} = $nextfile;
	  $cache{$file}->{min_hash} = $end;
	  $cache{$file}->{min_type} = 1;
	  $cache{$file}->{min_chunk} = $chunk;
	  $min = $end;
	  $hassame = 1;
	}
      }
    }

    next unless ($hassame);

    my @has_files = grep { defined $cache{$_}->{min_hash} } @files;
    my @sort_list = sort {
      $cache{$a}->{min_hash} <=> $cache{$b}->{min_hash}
    } @has_files;

    push @sort_group_files, \@sort_list;
  }

  return \@sort_group_files;
}

sub get_screenshot {
  if ("\L$config->{player}\E" =~ /mplayer/) {
    get_screenshot_by_mplayer (@_);
  }
}

sub get_screenshot_by_mplayer {
  my ($file, $time, $img) = @_;

  my ($name, $dir) = fileparse ($img);
  make_path ($dir);

  my $cmd =  "$config->{player} -ss $time -noframedrop -nosound -vo jpeg -frames 1 \"$file\"";
  unless ($OsIsWin || $config->{verbose}) {
    $cmd .= " >/dev/null 2>&1";
  }

  eval {
    local $SIG{ALRM} = sub { die "timeout\n" };
    alarm 5;
    `$cmd`;
    alarm 0;
  };
  if ($@) {
    printf "ERROR: get file \'$file\' screenshot failed\n";
  }

  move "00000001.jpg", $img;
}

sub get_imghash {
  my ($file, $timer) = @_;

  return $cache{$file}->{hash}->{$timer} if (exists ($cache{$file}->{hash}->{$timer}));

  my $imgfile = catfile ($cache{$file}->{cache_dir}, $timer . '.jpg');
  get_screenshot ($file, $timer, $imgfile) unless (-r $imgfile);

  return unless (-r $imgfile);

  my $img = Wx::Image->new ($imgfile, wxBITMAP_TYPE_JPEG);
  $img->Rescale (@{$config->{hash_size}});

  my @phrase;
  for my $w (0 .. $img->GetWidth - 1) {
    for my $h (0 .. $img->GetHeight - 1) {
      my($r, $g, $b) = ($img->GetRed ($w, $h),
			$img->GetGreen ($w, $h),
			$img->GetBlue ($w, $h)
		       );
      my $ch = ($r * 30 + $g * 59 + $b * 11) / 100;
      push @phrase, $ch;
    }
  }

  my $sum = 0;
  for (@phrase) {
    $sum += $_;
  }
  my $avg = $sum / @phrase;

  my $bin = 0;
  for (0 .. @phrase - 1) {
    $bin |= (1 << $_) if ($phrase[$_] >= $avg);
  }

  $cache{$file}->{hash}->{$timer} = $bin;
}

sub imghash_cmp {
  my ($bina, $binb) = @_;

  return $config->{hash_size}->[0] * $config->{hash_size}->[1] unless ($bina && $binb);

  my $sum = 0;
  my $odd = int ((int $bina) ^ (int $binb));
  while ($odd) {
    $sum ++ if ($odd & 1);
    $odd = $odd >> 1;
  }
  $sum;
}

sub find_filter {
  my $file = $File::Find::name;

  return if (-d $file);

  return unless (is_avfile ($file));

  file_parse ($file);
}

sub file_info_string {
  my $file = shift;

  return sprintf
    "File:%s\nFormat:%s\nLength:%s\nSize:%dx%d\n",
      basename ($file),
	$cache{$file}->{info}->{format},
	  $cache{$file}->{info}->{length},
	    $cache{$file}->{info}->{width},
	      $cache{$file}->{info}->{height};
}

sub file_parse {
  my $file = shift;

  my $info = get_info ($file);
  return unless ($info);

  my %nodes;
  $nodes{info} = $info;
  $cache{$file} = \%nodes;

  my $phrase = substr sha1_hex ($file), 0, 16;

  $nodes{phrase} = $phrase;
  $nodes{cache_dir} = catdir ($config->{workpath}, substr ($phrase, 0, 2), $phrase);
}

sub is_avfile {
  my $file = shift;
  my (undef, undef, $suffix) = fileparse ($file, @{$config->{av_suffix}});
  return 1 if ("\L$suffix\E" ~~ @{$config->{av_suffix}});
  0;
}

sub get_info {
  if ("\L$config->{player}\E" =~ /mplayer/) {
    return get_info_by_mplayer (@_);
  }
}

sub get_info_by_mplayer {
  my $file = shift;
  my @mpout;

  my $cmd = "$config->{player} -identify -nosound -vc dummy -vo null \"$file\"";
  unless ($OsIsWin || $config->{verbose}) {
    $cmd .= " 2>/dev/null";
  }

  eval {
    local $SIG{ALRM} = sub { die "timeout\n" };
    alarm 5;
    @mpout = `$cmd`;
    alarm 0;
  };
  if ($@) {
    printf "ERROR: \'$file\' get length error.\n";
    return;
  }

  my %info;

  for (@mpout) {
    given ($_) {
      $info{format} = $1 when (/(.+) file format detected/);
      $info{length} = $1 when (/ID_LENGTH=(\d*\.?\d*)/);
      $info{width} = $1 when (/ID_VIDEO_WIDTH=(\d+)/);
      $info{height} = $1 when (/ID_VIDEO_HEIGHT=(\d+)/);
      default {};
    }
  }
  return \%info;
}

sub display_help {
  my $str = "
    fdupves is a Perl script for finding duplicate video files in a given set of directories.
      -s -symlinks
        follow symlinked directories

      -y -yes
        not ask user, just think as yes

      -C -workpath
	output screenshot pics will be store here

      -m method
        compare method (length, auto, or manual)
          lenght: lowest level compare, just compare the video length
          auto: compare some screenshots in video automatically
          manual: compare some screenshots and display to user

      -d --delete
	prompt  user  for  files  to  preserve, deleting all others

      -v --verbose
	display more debug infomations

      -h --help
	displays help
";

  print $str;
}
